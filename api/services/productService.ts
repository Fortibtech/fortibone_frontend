import axiosInstance from "../axiosInstance";
import { cacheManager } from "../cache";
import {
  CreateProductData,
  CreateVariantData,
  PaginatedResponse,
  Product,
  ProductSearchFilters,
  ProductVariant,
  UpdateVariantData
} from "../types";

export class ProductService {
  private static readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes

  // ========== M√âTHODES EXISTANTES MISES √Ä JOUR ==========

  static async searchProducts(filters: ProductSearchFilters = {}): Promise<PaginatedResponse<Product>> {
    const cacheKey = `products_search_${JSON.stringify(filters)}`;
    
    // V√©rifier le cache
    const cachedData = await cacheManager.get<PaginatedResponse<Product>>(cacheKey);
    if (cachedData) {
      console.log("üì¶ R√©sultats de recherche r√©cup√©r√©s du cache");
      return cachedData;
    }

    try {
      const response = await axiosInstance.get<PaginatedResponse<Product>>("/products/search", {
        params: filters
      });
      
      // Mettre en cache
      await cacheManager.set(cacheKey, response.data, this.CACHE_TTL);
      
      console.log("‚úÖ Produits trouv√©s:", response.data.data.length);
      return response.data;
    } catch (error) {
      console.error("‚ùå Erreur lors de la recherche de produits:", error);
      throw error;
    }
  }

  static async createProduct(businessId: string, data: CreateProductData): Promise<Product> {
    try {
      const response = await axiosInstance.post<Product>(`/businesses/${businessId}/products`, data);
      
      // Invalider les caches li√©s
      await cacheManager.invalidatePattern("products_search");
      await cacheManager.invalidatePattern(`business_products_${businessId}`);
      
      console.log("‚úÖ Produit cr√©√©:", response.data.name);
      return response.data;
    } catch (error) {
      console.error("‚ùå Erreur lors de la cr√©ation du produit:", error);
      throw error;
    }
  }

  static async getBusinessProducts(
    businessId: string, 
    filters: { search?: string; page?: number; limit?: number; categoryId?: string } = {}
  ): Promise<PaginatedResponse<Product>> {
    const cacheKey = `business_products_${businessId}_${JSON.stringify(filters)}`;
    
    // V√©rifier le cache
    const cachedData = await cacheManager.get<PaginatedResponse<Product>>(cacheKey);
    if (cachedData) {
      console.log("üì¶ Produits de l'entreprise r√©cup√©r√©s du cache");
      return cachedData;
    }

    try {
      const response = await axiosInstance.get<PaginatedResponse<Product>>(`/businesses/${businessId}/products`, {
        params: filters
      });
      
      // Mettre en cache
      await cacheManager.set(cacheKey, response.data, this.CACHE_TTL);
      
      console.log("‚úÖ Produits de l'entreprise r√©cup√©r√©s:", response.data.data.length);
      return response.data;
    } catch (error) {
      console.error("‚ùå Erreur lors de la r√©cup√©ration des produits de l'entreprise:", error);
      throw error;
    }
  }

  static async getProductById(id: string): Promise<Product> {
    const cacheKey = `product_${id}`;
    
    // V√©rifier le cache
    const cachedData = await cacheManager.get<Product>(cacheKey);
    if (cachedData) {
      console.log("üì¶ Produit r√©cup√©r√© du cache:", cachedData.name);
      return cachedData;
    }

    try {
      const response = await axiosInstance.get<Product>(`/products/${id}`);
      
      // Mettre en cache
      await cacheManager.set(cacheKey, response.data, this.CACHE_TTL);
      
      console.log("‚úÖ Produit r√©cup√©r√©:", response.data.name);
      return response.data;
    } catch (error) {
      console.error("‚ùå Erreur lors de la r√©cup√©ration du produit:", error);
      throw error;
    }
  }

  static async updateProduct(id: string, data: Partial<CreateProductData>): Promise<Product> {
    try {
      const response = await axiosInstance.patch<Product>(`/products/${id}`, data);
      
      // Invalider les caches
      await cacheManager.invalidate(`product_${id}`);
      await cacheManager.invalidatePattern("products_search");
      await cacheManager.invalidatePattern(`business_products_${response.data.businessId}`);
      
      console.log("‚úÖ Produit mis √† jour:", response.data.name);
      return response.data;
    } catch (error) {
      console.error("‚ùå Erreur lors de la mise √† jour du produit:", error);
      throw error;
    }
  }

  static async uploadProductImage(id: string, file: any): Promise<void> {
    try {
      const formData = new FormData();
      formData.append('file', file);
      
      await axiosInstance.post(`/products/${id}/image`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      
      // Invalider le cache du produit
      await cacheManager.invalidate(`product_${id}`);
      
      console.log("‚úÖ Image du produit upload√©e");
    } catch (error) {
      console.error("‚ùå Erreur lors de l'upload de l'image du produit:", error);
      throw error;
    }
  }

  // ========== NOUVELLES M√âTHODES POUR LES VARIANTES ==========

  /**
   * Cr√©er une nouvelle variante pour un produit
   */
  static async createVariant(productId: string, data: CreateVariantData): Promise<ProductVariant> {
    try {
      const response = await axiosInstance.post<ProductVariant>(`/products/${productId}/variants`, data);
      
      // Invalider les caches li√©s au produit
      await cacheManager.invalidate(`product_${productId}`);
      await cacheManager.invalidatePattern("products_search");
      
      console.log("‚úÖ Variante cr√©√©e:", response.data.sku);
      return response.data;
    } catch (error) {
      console.error("‚ùå Erreur lors de la cr√©ation de la variante:", error);
      throw error;
    }
  }

  /**
   * Mettre √† jour une variante existante
   */
  static async updateVariant(variantId: string, data: UpdateVariantData): Promise<ProductVariant> {
    try {
      const response = await axiosInstance.patch<ProductVariant>(`/variants/${variantId}`, data);
      
      // Invalider les caches li√©s au produit
      await cacheManager.invalidate(`product_${response.data.productId}`);
      await cacheManager.invalidatePattern("products_search");
      
      console.log("‚úÖ Variante mise √† jour:", response.data.sku);
      return response.data;
    } catch (error) {
      console.error("‚ùå Erreur lors de la mise √† jour de la variante:", error);
      throw error;
    }
  }

  /**
   * Supprimer une variante
   */
  static async deleteVariant(variantId: string): Promise<void> {
    try {
      // R√©cup√©rer d'abord l'info de la variante pour invalider le cache du produit
      const variant = await axiosInstance.get<ProductVariant>(`/variants/${variantId}`);
      const productId = variant.data.productId;

      await axiosInstance.delete(`/variants/${variantId}`);
      
      // Invalider les caches li√©s au produit
      await cacheManager.invalidate(`product_${productId}`);
      await cacheManager.invalidatePattern("products_search");
      
      console.log("‚úÖ Variante supprim√©e");
    } catch (error) {
      console.error("‚ùå Erreur lors de la suppression de la variante:", error);
      throw error;
    }
  }

  /**
   * Supprimer un produit et toutes ses variantes
   */
  static async deleteProduct(productId: string): Promise<void> {
    try {
      // R√©cup√©rer d'abord l'info du produit pour invalider les bons caches
      const product = await axiosInstance.get<Product>(`/products/${productId}`);
      const businessId = product.data.businessId;

      await axiosInstance.delete(`/products/${productId}`);
      
      // Invalider tous les caches li√©s
      await cacheManager.invalidate(`product_${productId}`);
      await cacheManager.invalidatePattern("products_search");
      await cacheManager.invalidatePattern(`business_products_${businessId}`);
      
      console.log("‚úÖ Produit et ses variantes supprim√©s");
    } catch (error) {
      console.error("‚ùå Erreur lors de la suppression du produit:", error);
      throw error;
    }
  }

  /**
   * Upload d'une image pour une variante sp√©cifique
   */
  static async uploadVariantImage(variantId: string, file: any): Promise<void> {
    try {
      const formData = new FormData();
      formData.append('file', file);
      
      await axiosInstance.post(`/variants/${variantId}/image`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      
      // R√©cup√©rer l'info de la variante pour invalider le cache du produit
      const variant = await axiosInstance.get<ProductVariant>(`/variants/${variantId}`);
      await cacheManager.invalidate(`product_${variant.data.productId}`);
      
      console.log("‚úÖ Image de la variante upload√©e");
    } catch (error) {
      console.error("‚ùå Erreur lors de l'upload de l'image de la variante:", error);
      throw error;
    }
  }

  // ========== M√âTHODES UTILITAIRES ==========

  /**
   * Obtenir toutes les variantes d'un produit
   */
  static async getProductVariants(productId: string): Promise<ProductVariant[]> {
    try {
      const product = await this.getProductById(productId);
      return product.variants;
    } catch (error) {
      console.error("‚ùå Erreur lors de la r√©cup√©ration des variantes:", error);
      throw error;
    }
  }

  /**
   * Obtenir une variante sp√©cifique par son ID
   */
  static async getVariantById(variantId: string): Promise<ProductVariant> {
    try {
      const response = await axiosInstance.get<ProductVariant>(`/variants/${variantId}`);
      console.log("‚úÖ Variante r√©cup√©r√©e:", response.data.sku);
      return response.data;
    } catch (error) {
      console.error("‚ùå Erreur lors de la r√©cup√©ration de la variante:", error);
      throw error;
    }
  }

  /**
   * Calculer le stock total d'un produit (somme de toutes les variantes)
   */
  static getTotalStock(product: Product): number {
    return product.variants.reduce((total, variant) => total + variant.quantityInStock, 0);
  }

  /**
   * Obtenir la variante la moins ch√®re d'un produit
   */
  static getCheapestVariant(product: Product): ProductVariant | null {
    if (!product.variants.length) return null;
    
    return product.variants.reduce((cheapest, current) => {
      return parseFloat(current.price) < parseFloat(cheapest.price) ? current : cheapest;
    });
  }

  /**
   * Obtenir la variante la plus ch√®re d'un produit
   */
  static getMostExpensiveVariant(product: Product): ProductVariant | null {
    if (!product.variants.length) return null;
    
    return product.variants.reduce((expensive, current) => {
      return parseFloat(current.price) > parseFloat(expensive.price) ? current : expensive;
    });
  }
}